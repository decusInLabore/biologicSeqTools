cols2Index = NULL,
mode = "MySQL"
){
if (sum( nchar(names(df.data)) > 64) > 0){
print("Table names clipped to 64 characters.")
names(df.data) <- substr(names(df.data), 1, 64)
}
if (startOnlyWithConnectionCount1){
## helper function ##
getConnectonCount <- function(
user= "user",
password = "password",
dbname = "prim.data.db",
host = "host"){
dbDB <- dbConnect(
drv = RMySQL::MySQL(),
user = user,
password = password,
#dbname = prim.data.db,
host = host
)
connectionCount <- as.numeric(
dbGetQuery(
dbDB,
"SELECT COUNT(1) ConnectionCount, user FROM information_schema.processlist WHERE user <> 'system user' AND user = 'boeingS' GROUP BY user;"
)$ConnectionCount
)
dbDisconnect(dbDB)
return(connectionCount)
}
connectionCount <- getConnectonCount(
user= user,
password = password,
dbname = prim.data.db,
host = host
)
while (connectionCount > 2){
print(paste(connectionCount, "connections open. Sleep 30 seconds and try again."))
Sys.sleep(30)
connectionCount <- getConnectonCount(
user= user,
password = password,
dbname = prim.data.db,
host = host
)
}
}
## Uploading of data frame to database. Happens only if all columns are defined ##
# library(RMySQL)
## Connect to MySQL to check existence of database ##
if (mode == "SQLite"){
dbDB <- DBI::dbConnect(
drv = RSQLite::SQLite(),
dbname=prim.data.db
)
} else {
dbDB <- DBI::dbConnect(
drv = RMySQL::MySQL(),
user = user,
password = password,
host = host,
dbname=prim.data.db,
new.table = TRUE
)
}
## Create the database if it does not exist already##
res <- DBI::dbGetQuery(
dbDB,
paste(
"CREATE DATABASE IF NOT EXISTS ",
prim.data.db,
sep = ""
)
)
RMySQL::dbDisconnect(dbDB)
## Ensure that df.data has a row_names column ##
df.data[["row_names"]] <- first.row.name.index:(first.row.name.index+nrow(df.data)-1)
## Check if all columns are assigned in db.col.parameter.list ##
all.col.string.vec <- as.vector(do.call('c', db.col.parameter.list))
## Create a vector that contains all col names that contain at least in part the string in all.cols.vec
###############################################################################
## Function start                                                            ##
get.all.col.names.with.these.strings <- function(all.col.string.vec){
all.assigned.cols <- vector(mode="character", length=0)
for (i in 1:length(all.col.string.vec)){
pos <- grep(all.col.string.vec[i], names(df.data))
if (length(pos) > 0){
all.assigned.cols <- append(all.assigned.cols, names(df.data)[pos])
}
}
return(all.assigned.cols)
}
## End of function                                                           ##
###############################################################################
all.assigned.cols <- get.all.col.names.with.these.strings(all.col.string.vec)
## Ensure that all database columns are assigned ##
not.assigned <- names(df.data)[!(names(df.data) %in% all.assigned.cols)]
if (length(not.assigned) == 0){
print("All database columns are defined. Uploading to database...")
} else {
print(
paste0(
"The following database columns have not been defined: ",
paste(not.assigned,
collapse = ', '
),
". Datatable not uploaded to database.")
)
stop(not.assigned)
}
## Establish connection ##
if (mode == "SQLite"){
dbDB <- DBI::dbConnect(
drv = RSQLite::SQLite(),
dbname=prim.data.db
)
} else {
dbDB <- DBI::dbConnect(
drv = RMySQL::MySQL(),
user = user,
password = password,
host = host,
dbname=prim.data.db
)
}
## Remove all tables with the same name from db ##
if (new.table){
res <- DBI::dbGetQuery(
dbDB,
paste(
"DROP TABLE IF EXISTS ",
dbTableName,
sep = ""
)
)
RMySQL::dbDisconnect(dbDB)
}
## Upload up to increment rows in one go ##
iter <- nrow(df.data)%/%increment
if (nrow(df.data)%%increment != 0){
iter <- iter + 1
}
for (i in 1:iter){
if (nrow(df.data) > increment){
limit <- increment
} else {
limit <- nrow(df.data)
}
df.temp <- df.data[1:limit,]
df.data <- df.data[(increment+1):nrow(df.data),]
uploaded = FALSE
while (!uploaded){
tryCatch({
killDbConnections()
## Establish connection ##
if (mode == "SQLite"){
dbDB <- DBI::dbConnect(
drv = RSQLite::SQLite(),
dbname=prim.data.db
)
} else {
dbDB <- DBI::dbConnect(
drv = RMySQL::MySQL(),
user = user,
password = password,
host = host,
dbname=prim.data.db
)
}
## Upload new dataframe to database ##
res <- DBI::dbWriteTable(
dbDB,
dbTableName,
df.temp,
row.names = FALSE,
append = TRUE,
overwrite = FALSE
)
RMySQL::dbDisconnect(dbDB)
uploaded = TRUE
#dbDisconnect(dbDB)
}, error=function(e){cat("Upload errror :",conditionMessage(e), "\n")})
}
print(paste0(i * increment, " rows uploaded to database..."))
## Connect to database for dbtable upload  ##
}
####################################################
## Function alterDBtable
alterDBtable <- function(
cmd.string = "mysql command",
user = "user",
password = "password",
dbname = "prim.data.db",
host = "host"
){
## Establish connection ##
if (mode == "SQLite"){
dbDB <- DBI::dbConnect(
drv = RSQLite::SQLite(),
dbname=prim.data.db
)
} else {
dbDB <- DBI::dbConnect(
drv = RMySQL::MySQL(),
user = user,
password = password,
host = host,
dbname=prim.data.db
)
}
tryCatch({
DBI::dbGetQuery(
dbDB,
cmd.string
)}, error=function(e) {paste0("Alter not executed. cmd.vector[", i, "]")})
RMySQL::dbDisconnect(dbDB)
}
## End of function ##
######################
mysql.cmd = ""
if (new.table){
alterDBtable(
cmd.string = paste(
"ALTER TABLE `",
dbTableName,
"` ADD UNIQUE(`row_names`)",
sep = ""
),
user = user,
password = password,
dbname = dbname,
host = host
)
## Describe key columns in database table ##
mysql.cmd <- paste(
"ALTER TABLE `",
dbTableName,
"` ADD UNIQUE(`row_names`)",
sep = ""
)
alterDBtable(
cmd.string = paste(
"ALTER TABLE `",
dbTableName,
"` ADD PRIMARY KEY(`row_names`)",
sep = ""
),
user = user,
password = password,
dbname = dbname,
host = host
)
###############################################################################
## Characterize and define secondary database columns                        ##
for (i in 1:length(db.col.parameter.list)) {
descriptor <- names(db.col.parameter.list[i])
cols.in.class <-
get.all.col.names.with.these.strings(db.col.parameter.list[[i]])
if (length(cols.in.class) > 0) {
print(
paste0(
"Assigned ",
paste0(cols.in.class, collapse = ', '),
" as ",
descriptor, "."
)
)
## Assign column names to MySQL class ##
alteration.string <-
paste0("ALTER TABLE ", dbTableName, " ")
for (j in 1:length(cols.in.class)) {
alteration.string <- paste0(
alteration.string,
paste0(
"CHANGE `", cols.in.class[j], "` `", cols.in.class[j], "` ", descriptor, ", "
)
)
}
## Remove last comma from string
alteration.string <-
substr(alteration.string, 1, (nchar(alteration.string) - 2))
## Carry out alteration
## Connect to database for dbtable upload  ##
## Connection is repated to avoid loss of a short lived connection.
alterDBtable(
cmd.string = alteration.string,
user = user,
password = password,
dbname = dbname,
host = host
)
}
#print(alteration.string)
mysql.cmd <- append(mysql.cmd,
alteration.string)
#dbGetQuery(dbDB,
#           alteration.string)
}
}
## End characterize and define secondary database columns                  ##
#############################################################################
## Add index based on row namems ##
if (length(cols2Index) > 0){
for (i in 1:length(cols2Index)){
print("...indexing...")
cmd.string <- paste0("CREATE INDEX idx_",cols2Index[i]," ON ",dbTableName," (",cols2Index[i],")")
## Establish connection ##
if (mode == "SQLite"){
dbDB <- DBI::dbConnect(
drv = RSQLite::SQLite(),
dbname=prim.data.db
)
} else {
dbDB <- DBI::dbConnect(
drv = RMySQL::MySQL(),
user = user,
password = password,
host = host,
dbname=prim.data.db
)
}
tryCatch({
DBI::dbGetQuery(
dbDB,
cmd.string
)}, error=function(e) {stop(paste0("Database table not uploaded. Problem adding index ",cols2Index[i],"."))})
dbDisconnect(dbDB)
print(paste0("Datatable ", dbTableName, " successfully uploaded and column(s) ",paste(cols2Index, collapse = " ")," indexed."))
}
}
return(mysql.cmd)
}
inferDBcategories <- function(
dfData
){
dbCatList <- list()
for (i in 1:length(dfData)){
classLabel <- ""
maxStringLength <- max(nchar(as.character(dfData[,i])), na.rm = T) + 2
if (is.numeric(dfData[,i])){
if (is.integer(dfData[,i])){
if (maxStringLength <= 8) {
classLabel <- "INT(8) NULL DEFAULT NULL"
} else {
classLabel <- "BIGINT(8) NULL DEFAULT NULL"
}
} else {
if (max(dfData[,i], na.rm = T) <= 1){
classLabel <- "DECIMAL(6,5) NULL DEFAULT NULL"
} else {
classLabel <- "DECIMAL(6,3) NULL DEFAULT NULL"
}
}
} else {
## Running as character
classLabel <- "VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci"
if (maxStringLength < 100){
classLabel <- "VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci"
} else if (maxStringLength < 50){
classLabel <- "VARCHAR(50) CHARACTER SET utf8 COLLATE utf8_general_ci"
} else if (maxStringLength < 10){
classLabel <- "VARCHAR(10) CHARACTER SET utf8 COLLATE utf8_general_ci"
}
}
pos <- grep(classLabel, names(dbCatList), fixed=TRUE)
if (length(pos) > 0 ){
dbCatList[[classLabel]] <- c(dbCatList[[classLabel]], paste0("^", names(dfData)[i], "$"))
} else {
dbCatList[[classLabel]] <- paste0("^", names(dfData)[i], "$")
}
}
## Make sure row_names is prsent ##
classLabel <- "BIGINT(8) NULL DEFAULT NULL"
pos <- grep(classLabel, names(dbCatList), fixed=TRUE)
if (length(pos) > 0){
dbCatList[[classLabel]] <- c(dbCatList[[classLabel]], paste0("^row_names$"))
} else {
dbCatList[[classLabel]] <- paste0("^row_names$")
}
return(dbCatList)
}
head(mtcars)
dfData <- data.frame(mtcars)
inferDBcategories(
dfData
)
paramlist <- inferDBcategories(
dfData
)
upload.datatable.to.database <- function(
host = NULL,
user = NULL,
password = NULL,
prim.data.db = "mtcars",
dbTableName = "cars",
df.data = dfData,
db.col.parameter.list = paramlist,
increment = 5000,
new.table = TRUE,
first.row.name.index = 1,
startOnlyWithConnectionCount1 = FALSE,
cols2Index = NULL,
mode = "SQLite"
)
upload.datatable.to.database(
host = NULL,
user = NULL,
password = NULL,
prim.data.db = "mtcars",
dbTableName = "cars",
df.data = dfData,
db.col.parameter.list = paramlist,
increment = 5000,
new.table = TRUE,
first.row.name.index = 1,
startOnlyWithConnectionCount1 = FALSE,
cols2Index = NULL,
mode = "SQLite"
)
host = NULL
user = NULL
password = NULL
prim.data.db = "mtcars"
dbTableName = "cars"
df.data = dfData
db.col.parameter.list = paramlist
increment = 5000
new.table = TRUE
first.row.name.index = 1
startOnlyWithConnectionCount1 = FALSE
cols2Index = NULL
mode = "SQLite"
if (sum( nchar(names(df.data)) > 64) > 0){
print("Table names clipped to 64 characters.")
names(df.data) <- substr(names(df.data), 1, 64)
}
startOnlyWithConnectionCount1
connectionCount <- getConnectonCount(
user= user,
password = password,
dbname = prim.data.db,
host = host
)
getConnectonCount <- function(
user= "user",
password = "password",
dbname = "prim.data.db",
host = "host"){
f (mode == "SQLite"){
dbDB <- DBI::dbConnect(
drv = RSQLite::SQLite()
)
} else {
dbDB <- DBI::dbConnect(
drv = RMySQL::MySQL(),
user = user,
password = password,
host = host,
)
}
connectionCount <- as.numeric(
DBI::dbGetQuery(
dbDB,
"SELECT COUNT(1) ConnectionCount, user FROM information_schema.processlist WHERE user <> 'system user' AND user = 'boeingS' GROUP BY user;"
)$ConnectionCount
)
DBI::dbDisconnect(dbDB)
return(connectionCount)
}
getConnectonCount <- function(
user= "user",
password = "password",
dbname = "prim.data.db",
host = "host"){
if (mode == "SQLite"){
dbDB <- DBI::dbConnect(
drv = RSQLite::SQLite()
)
} else {
dbDB <- DBI::dbConnect(
drv = RMySQL::MySQL(),
user = user,
password = password,
host = host,
)
}
connectionCount <- as.numeric(
DBI::dbGetQuery(
dbDB,
"SELECT COUNT(1) ConnectionCount, user FROM information_schema.processlist WHERE user <> 'system user' AND user = 'boeingS' GROUP BY user;"
)$ConnectionCount
)
DBI::dbDisconnect(dbDB)
return(connectionCount)
}
connectionCount <- getConnectonCount(
user= user,
password = password,
dbname = prim.data.db,
host = host
)
substr("abc", 1,2)
setwd("Y:/working/boeings/Projects/boeings/stefan.boeing/biologicSeqTools")
devtools::check()
rm(list=ls())
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
getwd()
